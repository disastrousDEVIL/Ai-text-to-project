[
  {
    "path": "ai_powershell_automation/main.py",
    "filename": "main.py",
    "project": "ai_powershell_automation",
    "language": "py",
    "content": "\"\"\"\nMain script for AI-powered code generation using local Ollama server.\nHandles user interaction and orchestrates the entire workflow.\n\"\"\"\n\nimport sys\nimport os\nfrom ai_client import OllamaClient\nfrom parser import CodeBlockParser\nfrom file_creator import FileCreator\n\ndef get_user_prompt():\n    \"\"\"Get natural language prompt from user.\"\"\"\n    print(\"ü§ñ AI Code Generator\")\n    print(\"=\" * 50)\n    prompt = input(\"Enter your project description: \").strip()\n    \n    if not prompt:\n        print(\"‚ùå Error: Please provide a valid prompt.\")\n        return None\n    \n    return prompt\n\ndef generate_folder_name(prompt):\n    \"\"\"Generate folder name from first three words of prompt.\"\"\"\n    words = prompt.lower().split()[:3]\n    # Clean words to be filesystem-safe\n    clean_words = []\n    for word in words:\n        clean_word = ''.join(c for c in word if c.isalnum())\n        if clean_word:\n            clean_words.append(clean_word)\n    \n    return '_'.join(clean_words) if clean_words else 'ai_generated_project'\n\ndef main():\n    \"\"\"Main application flow.\"\"\"\n    try:\n        # Get user prompt\n        user_prompt = get_user_prompt()\n        if not user_prompt:\n            return\n        \n        print(f\"\\nüîÑ Processing: '{user_prompt}'\")\n        \n        # Initialize components\n        ollama_client = OllamaClient()\n        parser = CodeBlockParser()\n        file_creator = FileCreator()\n        \n        # Send request to Ollama\n        print(\"üì° Sending request to Ollama server...\")\n        response_text = ollama_client.generate_code(user_prompt)\n        \n        if not response_text:\n            print(\"‚ùå Failed to get response from Ollama server.\")\n            return\n        \n        # Parse code blocks from response\n        print(\"üîç Parsing code blocks...\")\n        files_data = parser.parse_code_blocks(response_text)\n        \n        if not files_data:\n            print(\"‚ö†Ô∏è  No code blocks found in response.\")\n            print(\"Raw response:\")\n            print(response_text[:500] + \"...\" if len(response_text) > 500 else response_text)\n            return\n        \n        # Generate folder name and create files\n        folder_name = generate_folder_name(user_prompt)\n        print(f\"üìÅ Creating project in folder: {folder_name}\")\n        \n        success = file_creator.create_project(folder_name, files_data)\n        \n        if success:\n            print(f\"\\n‚úÖ Project created successfully!\")\n            print(f\"üìÇ Location: ./{folder_name}/\")\n            print(f\"üìÑ Files created: {len(files_data)}\")\n            for filename in files_data.keys():\n                print(f\"   - {filename}\")\n        else:\n            print(\"‚ùå Failed to create project files.\")\n    \n    except KeyboardInterrupt:\n        print(\"\\n\\nüëã Goodbye!\")\n    except Exception as e:\n        print(f\"‚ùå Unexpected error: {str(e)}\")\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "path": "ai_powershell_automation/ai_client.py",
    "filename": "ai_client.py",
    "project": "ai_powershell_automation",
    "language": "py",
    "content": "\"\"\"\nHandles communication with the local Ollama server.\nSends HTTP requests and manages responses.\n\"\"\"\n\nimport requests\nimport json\nimport time\n\nclass OllamaClient:\n    def __init__(self, base_url=\"http://localhost:11434\", model=\"deepseek-coder\"):\n        \"\"\"Initialize Ollama client with server URL and model.\"\"\"\n        self.base_url = base_url\n        self.model = model\n        self.generate_url = f\"{base_url}/api/generate\"\n        self.timeout = 120  # 2 minutes timeout\n    \n    def check_server_health(self):\n        \"\"\"Check if Ollama server is running and accessible.\"\"\"\n        try:\n            health_url = f\"{self.base_url}/api/tags\"\n            response = requests.get(health_url, timeout=5)\n            return response.status_code == 200\n        except requests.RequestException:\n            return False\n    \n    def generate_code(self, prompt):\n        \"\"\"\n        Send code generation request to Ollama server.\n        Returns the complete response text or None if failed.\n        \"\"\"\n        if not self.check_server_health():\n            print(\"‚ùå Cannot connect to Ollama server. Please ensure:\")\n            print(\"   - Ollama is installed and running\")\n            print(\"   - Server is accessible at http://localhost:11434\")\n            print(\"   - Deepseek-Coder model is available\")\n            return None\n        \n        # Enhanced prompt for better code generation\n        enhanced_prompt = f\"\"\"\nGenerate a complete project for: {prompt}\n\nPlease provide the response with clear file structure using markdown code blocks.\nFormat each file like this:\n```filename.ext\n[file content here]\n```\n\nInclude all necessary files (HTML, CSS, JavaScript, Python, etc.) with proper file extensions.\nMake the code production-ready and well-commented.\n\"\"\"\n        \n        payload = {\n            \"model\": self.model,\n            \"prompt\": enhanced_prompt,\n            \"stream\": False,\n            \"options\": {\n                \"temperature\": 0.7,\n                \"top_k\": 40,\n                \"top_p\": 0.9\n            }\n        }\n        \n        try:\n            print(f\"üîó Connecting to {self.generate_url}\")\n            \n            response = requests.post(\n                self.generate_url,\n                json=payload,\n                timeout=self.timeout,\n                headers={'Content-Type': 'application/json'}\n            )\n            \n            response.raise_for_status()\n            \n            result = response.json()\n            \n            if 'response' in result:\n                return result['response']\n            else:\n                print(\"‚ùå Unexpected response format from Ollama\")\n                print(f\"Response keys: {list(result.keys())}\")\n                return None\n                \n        except requests.exceptions.Timeout:\n            print(f\"‚è∞ Request timed out after {self.timeout} seconds\")\n            return None\n        except requests.exceptions.ConnectionError:\n            print(\"‚ùå Connection error. Is Ollama server running?\")\n            return None\n        except requests.exceptions.HTTPError as e:\n            print(f\"‚ùå HTTP error: {e}\")\n            return None\n        except json.JSONDecodeError:\n            print(\"‚ùå Invalid JSON response from server\")\n            return None\n        except Exception as e:\n            print(f\"‚ùå Unexpected error: {str(e)}\")\n            return None\n"
  },
  {
    "path": "ai_powershell_automation/parser.py",
    "filename": "parser.py",
    "project": "ai_powershell_automation",
    "language": "py",
    "content": "\"\"\"\nParses markdown code blocks from Ollama response.\nExtracts filenames and corresponding code content.\n\"\"\"\n\nimport re\nfrom typing import Dict, Optional\n\nclass CodeBlockParser:\n    def __init__(self):\n        \"\"\"Initialize the parser with regex patterns.\"\"\"\n        # Pattern to match markdown code blocks with optional language/filename\n        self.code_block_pattern = re.compile(\n            r'```(?:(\\w+(?:\\.\\w+)*)|(\\w+))?\\s*\\n(.*?)```',\n            re.DOTALL | re.MULTILINE\n        )\n        \n        # Pattern to match filename comments in code\n        self.filename_comment_pattern = re.compile(\n            r'(?:#|//|<!--)\\s*(?:filename|file):\\s*([^\\s\\n]+)',\n            re.IGNORECASE\n        )\n    \n    def extract_filename_from_content(self, content: str, language: str = \"\") -> Optional[str]:\n        \"\"\"Extract filename from code content comments.\"\"\"\n        # Look for filename comments\n        match = self.filename_comment_pattern.search(content)\n        if match:\n            return match.group(1).strip()\n        \n        # Default filenames based on language\n        default_extensions = {\n            'html': 'index.html',\n            'css': 'styles.css',\n            'javascript': 'script.js',\n            'js': 'script.js',\n            'python': 'main.py',\n            'py': 'main.py',\n            'java': 'Main.java',\n            'cpp': 'main.cpp',\n            'c': 'main.c',\n            'php': 'index.php',\n            'ruby': 'main.rb',\n            'go': 'main.go',\n            'rust': 'main.rs',\n            'swift': 'main.swift',\n            'kotlin': 'main.kt',\n            'typescript': 'main.ts',\n            'ts': 'main.ts'\n        }\n        \n        return default_extensions.get(language.lower(), f\"file.{language.lower()}\" if language else \"code.txt\")\n    \n    def clean_code_content(self, content: str) -> str:\n        \"\"\"Clean and prepare code content for file writing.\"\"\"\n        # Remove filename comments\n        content = self.filename_comment_pattern.sub('', content)\n        \n        # Strip leading/trailing whitespace but preserve internal formatting\n        content = content.strip()\n        \n        # Ensure file ends with newline\n        if content and not content.endswith('\\n'):\n            content += '\\n'\n        \n        return content\n    \n    def parse_code_blocks(self, response_text: str) -> Dict[str, str]:\n        \"\"\"\n        Parse markdown code blocks from Ollama response.\n        Returns a dictionary mapping filenames to their content.\n        \"\"\"\n        files_data = {}\n        \n        if not response_text:\n            return files_data\n        \n        # Find all code blocks\n        matches = self.code_block_pattern.findall(response_text)\n        \n        for match in matches:\n            filename_or_lang = match[0] or match[1] or \"\"\n            content = match[2]\n            \n            if not content.strip():\n                continue\n            \n            # Determine if the first capture group is a filename or language\n            if '.' in filename_or_lang and not filename_or_lang.startswith('.'):\n                # Likely a filename\n                filename = filename_or_lang\n                language = filename.split('.')[-1] if '.' in filename else \"\"\n            else:\n                # Likely a language identifier\n                language = filename_or_lang\n                filename = self.extract_filename_from_content(content, language)\n            \n            # Clean the content\n            clean_content = self.clean_code_content(content)\n            \n            # Handle duplicate filenames\n            original_filename = filename\n            counter = 1\n            while filename in files_data:\n                name, ext = os.path.splitext(original_filename)\n                filename = f\"{name}_{counter}{ext}\"\n                counter += 1\n            \n            files_data[filename] = clean_content\n            print(f\"   üìÑ Parsed: {filename} ({len(clean_content)} chars)\")\n        \n        return files_data\n    \n    def detect_project_type(self, files_data: Dict[str, str]) -> str:\n        \"\"\"Detect the type of project based on file extensions.\"\"\"\n        extensions = set()\n        for filename in files_data.keys():\n            if '.' in filename:\n                ext = filename.split('.')[-1].lower()\n                extensions.add(ext)\n        \n        if 'html' in extensions:\n            return \"Web Application\"\n        elif 'py' in extensions:\n            return \"Python Project\"\n        elif 'js' in extensions and 'json' in extensions:\n            return \"Node.js Project\"\n        elif 'java' in extensions:\n            return \"Java Project\"\n        elif 'cpp' in extensions or 'c' in extensions:\n            return \"C/C++ Project\"\n        else:\n            return \"Mixed Project\"\n"
  },
  {
    "path": "ai_powershell_automation/file_creator.py",
    "filename": "file_creator.py",
    "project": "ai_powershell_automation",
    "language": "py",
    "content": "\"\"\"\nHandles creation of project directories and files.\nManages file system operations with proper error handling.\n\"\"\"\n\nimport os\nimport shutil\nfrom typing import Dict\n\nclass FileCreator:\n    def __init__(self):\n        \"\"\"Initialize file creator.\"\"\"\n        self.created_files = []\n        self.created_dirs = []\n    \n    def sanitize_filename(self, filename: str) -> str:\n        \"\"\"Sanitize filename to be filesystem-safe.\"\"\"\n        # Remove or replace invalid characters\n        invalid_chars = '<>:\"/\\\\|?*'\n        for char in invalid_chars:\n            filename = filename.replace(char, '_')\n        \n        # Remove leading/trailing dots and spaces\n        filename = filename.strip('. ')\n        \n        # Ensure filename is not empty\n        if not filename:\n            filename = \"untitled\"\n        \n        return filename\n    \n    def create_directory(self, dir_path: str) -> bool:\n        \"\"\"Create directory if it doesn't exist.\"\"\"\n        try:\n            if os.path.exists(dir_path):\n                print(f\"‚ö†Ô∏è  Directory {dir_path} already exists.\")\n                \n                # Ask user if they want to continue\n                response = input(\"Do you want to continue and potentially overwrite files? (y/N): \").strip().lower()\n                if response not in ['y', 'yes']:\n                    print(\"Operation cancelled by user.\")\n                    return False\n                \n                # Backup existing directory\n                backup_path = f\"{dir_path}_backup_{int(time.time())}\"\n                print(f\"üì¶ Creating backup at: {backup_path}\")\n                shutil.copytree(dir_path, backup_path)\n            \n            os.makedirs(dir_path, exist_ok=True)\n            self.created_dirs.append(dir_path)\n            print(f\"üìÅ Created directory: {dir_path}\")\n            return True\n            \n        except PermissionError:\n            print(f\"‚ùå Permission denied creating directory: {dir_path}\")\n            return False\n        except Exception as e:\n            print(f\"‚ùå Error creating directory {dir_path}: {str(e)}\")\n            return False\n    \n    def write_file(self, file_path: str, content: str) -> bool:\n        \"\"\"Write content to file with proper error handling.\"\"\"\n        try:\n            # Create parent directories if they don't exist\n            parent_dir = os.path.dirname(file_path)\n            if parent_dir and not os.path.exists(parent_dir):\n                os.makedirs(parent_dir, exist_ok=True)\n            \n            # Write file\n            with open(file_path, 'w', encoding='utf-8') as f:\n                f.write(content)\n            \n            self.created_files.append(file_path)\n            file_size = len(content.encode('utf-8'))\n            print(f\"   ‚úÖ Created: {os.path.basename(file_path)} ({file_size} bytes)\")\n            return True\n            \n        except PermissionError:\n            print(f\"‚ùå Permission denied writing file: {file_path}\")\n            return False\n        except UnicodeEncodeError:\n            print(f\"‚ùå Unicode encoding error for file: {file_path}\")\n            return False\n        except Exception as e:\n            print(f\"‚ùå Error writing file {file_path}: {str(e)}\")\n            return False\n    \n    def create_project(self, folder_name: str, files_data: Dict[str, str]) -> bool:\n        \"\"\"\n        Create complete project with folder and all files.\n        Returns True if successful, False otherwise.\n        \"\"\"\n        if not files_data:\n            print(\"‚ùå No files to create.\")\n            return False\n        \n        # Sanitize folder name\n        folder_name = self.sanitize_filename(folder_name)\n        \n        # Create main project directory\n        if not self.create_directory(folder_name):\n            return False\n        \n        success_count = 0\n        total_files = len(files_data)\n        \n        # Create each file\n        for filename, content in files_data.items():\n            sanitized_filename = self.sanitize_filename(filename)\n            file_path = os.path.join(folder_name, sanitized_filename)\n            \n            if self.write_file(file_path, content):\n                success_count += 1\n            else:\n                print(f\"‚ö†Ô∏è  Failed to create: {sanitized_filename}\")\n        \n        # Create a README.md with project info\n        readme_content = f\"\"\"# {folder_name.replace('_', ' ').title()}\n\nThis project was generated using AI-powered code generation.\n\n## Files Created:\n{chr(10).join(f'- {filename}' for filename in files_data.keys())}\n\n## Generated on:\n{time.strftime('%Y-%m-%d %H:%M:%S')}\n\n## Setup Instructions:\n1. Navigate to this directory\n2. Follow any setup instructions in the generated files\n3. Install any required dependencies\n\"\"\"\n        \n        readme_path = os.path.join(folder_name, \"README.md\")\n        self.write_file(readme_path, readme_content)\n        \n        print(f\"\\nüìä Summary: {success_count}/{total_files} files created successfully\")\n        \n        return success_count > 0\n    \n    def cleanup_on_failure(self):\n        \"\"\"Clean up created files and directories on failure.\"\"\"\n        print(\"üßπ Cleaning up created files...\")\n        \n        # Remove created files\n        for file_path in reversed(self.created_files):\n            try:\n                if os.path.exists(file_path):\n                    os.remove(file_path)\n                    print(f\"   üóëÔ∏è  Removed: {file_path}\")\n            except Exception as e:\n                print(f\"   ‚ö†Ô∏è  Could not remove {file_path}: {str(e)}\")\n        \n        # Remove created directories\n        for dir_path in reversed(self.created_dirs):\n            try:\n                if os.path.exists(dir_path) and not os.listdir(dir_path):\n                    os.rmdir(dir_path)\n                    print(f\"   üóëÔ∏è  Removed directory: {dir_path}\")\n            except Exception as e:\n                print(f\"   ‚ö†Ô∏è  Could not remove directory {dir_path}: {str(e)}\")\n\nimport time  # Add this import at the top\n"
  },
  {
    "path": "ai_powershell_automation/requirements.txt",
    "filename": "requirements.txt",
    "project": "ai_powershell_automation",
    "language": "txt",
    "content": "# Core dependencies for AI PowerShell Automation\nrequests>=2.31.0\npython-dotenv>=1.0.0\n\n# Optional: For enhanced parsing and validation\npyyaml>=6.0\n\n# Development dependencies (optional)\n# pytest>=7.0.0\n# black>=23.0.0\n# flake8>=6.0.0\n"
  }
]